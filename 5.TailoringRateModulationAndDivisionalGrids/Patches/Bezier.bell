QuadraticBezier=($t,$pts->
(
  ((1-$t)**2) * ($pts::1) + 2*$t*(1-$t) * ($pts::2) + ($t**2) * ($pts::3)
));

QuadraticBezierDerivative=($t,$pts->
(
  -2*(1-$t) * ($pts::1) + (-2*$t+2*(1-$t)) * ($pts::2) + 2*$t * ($pts::3)
));

QuadraticBezierFindT=($x,$pts->
(
  ## solving Bezier(t):1=x
  $tleft=0;
  $tright=1;
  for $n in 1 ... 50 do (
    $tmid = 0.5*($tleft+$tright);
    if (QuadraticBezier($tmid,$pts):1 >= $x) then
      $tright = $tmid else $tleft = $tmid
  );

  0.5*($tleft+$tright)
));

QuadraticBezierYtoX=($y,$pts->
(
  ## solving Bezier(t):1=x
  $tleft=0;
  $tright=1;
  for $n in 1 ... 50 do (
    $tmid = 0.5*($tleft+$tright);
    if (QuadraticBezier($tmid,$pts):2 >= $y) then
      $tright = $tmid else $tleft = $tmid
  );

  QuadraticBezier(0.5*($tleft+$tright), $pts):1
));

BezierPt=($t,$a,$b,$c,$d->
(
  (3*(1-$t)**2)*$t*$a+3*(1-$t)*($t**2)*$c+$t**3
  ((1-$t)**3) + 3*((1-$t)**2)*$t*$b + 3*(1-$t)*($t**2)*$d+2*($t**3)
));

BezierDerivative=($t,$a,$b,$c,$d->
(
  3*($a*(3*($t**2) - 4*$t + 1) + $t*($c*(2 - 3*t) + $t))
  3*(-3*$b*($t**2) + $b + (1 - 3*$d)*($t**2) + 2*($d + 1)*$t - 1)
));

## integral in dt, not in dx!
BezierIntegraldT=($t,$a,$b,$c,$d->
(
  3 *($a*$t+ 1./2.*(-7*$a+3*$a*$b+2*$c)*($t**2)+
  (1./3.)*(1+18*$a-18*$a*$b-9*$c+6*$b*$c+3*$a*$d)*($t**3)+
  (1./4.)*(-3-20*$a+3*$b+36*$a*$b+15*$c-21*$b*$c-15*$a*$d+6*$c*$d)*($t**4)+
  (1./5.)*(3+5*$a-6*$b-30*$a*$b-7*$c+24*$b*$c+3*$d+21*$a*$d-15*$c*$d)*($t**5)+
  (1./6.)*(-1-3*$a+3*$c)*(-1-3*$b+3*$d)*($t**6))
));

BezierFindTNewton=($x,$a,$b,$c,$d->
(
  ## solving Bezier(t):1-x=0
  $t = $x;
  for $n in 1 ... 50 do (
      $t -= (BezierPt($t,$a,$b,$c,$d):1 - $x) / (BezierDerivative($t,$a,$b,$c,$d):1)
  );
  if $t < 0 then 0 else if $t > 1 then 1 else $t
));

BezierFindT=($x,$a,$b,$c,$d->
(
  ## solving Bezier(t):1=x
  $tleft=0;
  $tright=1;
  for $n in 1 ... 50 do (
    $tmid = 0.5*($tleft+$tright);
    if (BezierPt($tmid,$a,$b,$c,$d):1 >= $x) then
      $tright = $tmid else $tleft = $tmid
  );

  0.5*($tleft+$tright)
));

BezierFromX=($x,$a,$b,$c,$d->
(
  $t=BezierFindT($x,$a,$b,$c,$d);
  BezierPt($t,$a,$b,$c,$d)
));

BezierIntegraldX=($x,$a,$b,$c,$d->
(
  $t=BezierFindT($x,$a,$b,$c,$d);
  BezierIntegraldT($t,$a,$b,$c,$d)
));

BezierIntegralInverse=($v, $a,$b,$c,$d->
(
  ## F(x)-F(1)/2 = 0
  $constant=$v;
  $x = 0.5;
  for $n in 1 ... 10 do (
    $x -= (BezierIntegraldX($x,$a,$b,$c,$d) - $constant) / (BezierFromX($x,$a,$b,$c,$d):2)
  );
  $x
));

BezierFindSplitPoint=($a,$b,$c,$d->
(
  ## F(x)-F(1)/2 = 0
  $constant=BezierIntegraldT(1,$a,$b,$c,$d)/2.;
  print($constant, 'c');
  $x = 0.5;
  for $n in 1 ... 10 do (
    print($x, 'x');
    print(BezierIntegraldX($x,$a,$b,$c,$d), 'integral');
    print(BezierFromX($x,$a,$b,$c,$d), 'bezfromx');
      $x -= (BezierIntegraldX($x,$a,$b,$c,$d) - $constant) / (BezierFromX($x,$a,$b,$c,$d):2)
  );
  $x

));

BezierIntegralTrapezi=($a,$b,$c,$d,$prec=100->
(
  $res = 0;
  $N = $prec;
  $dx = 1./$N;
  ( for $x in arithmser(0,1,'none',$N).left(-1) do (
      $res += 0.5*(BezierFromX($x, $a,$b,$c,$d):2 + BezierFromX($x+$dx, $a,$b,$c,$d):2)*$dx
  ));
  $res
));

ReciprocalIntegralTrapezi=($a,$b,$c,$d,$prec=100->
(
  $res = 0;
  $N = $prec;
  $dx = 1./$N;
  ( for $x in arithmser(0,1,'none',$N).left(-1) do (
    $res += 0.5*(1./(BezierFromX($x, $a,$b,$c,$d):2) + 1./(BezierFromX($x+$dx, $a,$b,$c,$d):2))*$dx
  ));
  $res
));

QuadraticInterpolationDo=($t, $pts ->
(
    print(($pts:(1 2))*($t - ($pts:(2 1)))*($t - ($pts:(3 1)))/((($pts:(1 1)) - ($pts:(2 1)))*(($pts:(1 1)) - ($pts:(3 1))))) +
    print(print($pts:(2 2))*($t - ($pts:(1 1)))*($t - ($pts:(3 1)))/((($pts:(2 1)) - ($pts:(1 1)))*(($pts:(2 1)) - ($pts:(3 1))))) +
    print(($pts:(3 2))*($t - ($pts:(1 1)))*($t - ($pts:(2 1)))/((($pts:(3 1)) - ($pts:(1 1)))*(($pts:(3 1)) - ($pts:(2 1)))))
));

QuadraticInterpolation=($t, $pts ->
(
  $i = 0;
  (while ($i < $pts.length() && $pts:($i 1) < $t) do $i += 1);
  (if ($i > 1) then $i -= 1);
  (while ($i > 1 && $i+2 > $pts.length()) do $i -= 1);
  $t QuadraticInterpolationDo($t, $pts:$i $pts:($i+1) $pts:($i+2))
));

QuadraticBezierInterpolation=($pts, $ctrlpts ->
(
  $N=100;
  for $i in 1 ... $pts.length()-1 collect (
    for $t in (if $i == $pts.length()-1 then
      arithmser(0,1,'none',$N) else arithmser(0,1,'none',$N).left(-1)) collect
      [QuadraticBezier($t, $pts:$i $ctrlpts:$i $pts:($i+1))]
  )
));

GetControlPoints=($pts ->
(
));

null
